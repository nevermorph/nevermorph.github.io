{"meta":{"title":"nirvana->zen","subtitle":"金光烁屋 锐气盈庭","description":"金光烁屋 锐气盈庭","author":"nirvana. w.l.","url":"https://nevermorph.github.io"},"pages":[{"title":"tags","date":"2017-06-22T14:49:38.000Z","updated":"2017-06-22T14:50:16.565Z","comments":true,"path":"tags/index.html","permalink":"https://nevermorph.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-22T15:01:40.000Z","updated":"2017-06-22T15:14:29.075Z","comments":true,"path":"categories/index.html","permalink":"https://nevermorph.github.io/categories/index.html","excerpt":"","text":""},{"title":"email","date":"2017-07-15T03:40:16.000Z","updated":"2017-07-23T07:56:35.495Z","comments":true,"path":"email/index.html","permalink":"https://nevermorph.github.io/email/index.html","excerpt":"","text":"我的邮箱是nirvanaZen@aliyun.com ，欢迎大家共同探讨。"}],"posts":[{"title":"壁面条件","slug":"壁面条件","date":"2018-01-01T13:32:52.000Z","updated":"2018-01-01T13:32:52.323Z","comments":true,"path":"2018/01/01/壁面条件/","link":"","permalink":"https://nevermorph.github.io/2018/01/01/壁面条件/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"湍流模拟常用数学公式","slug":"湍流模拟常见物理量","date":"2017-08-02T14:41:15.000Z","updated":"2018-01-01T13:29:18.088Z","comments":true,"path":"2017/08/02/湍流模拟常见物理量/","link":"","permalink":"https://nevermorph.github.io/2017/08/02/湍流模拟常见物理量/","excerpt":"统计平均量与湍流描述 实验中得到的湍流信号是一个随机量，因此常常使用统计学概念描述一些物理现象，下面是一些统计量和其物理概念:","text":"统计平均量与湍流描述 实验中得到的湍流信号是一个随机量，因此常常使用统计学概念描述一些物理现象，下面是一些统计量和其物理概念: 雷诺平均(Reynolds Average)雷诺分解将任意瞬时的速度分解脉动量与平均量如(1)所示:$$u=\\overline{u}+u’\\tag{1}$$其中$\\overline{u}$为u的平均值，$u’$即每时刻的脉动值。 期望值(expect value)变量$X$的期望值其公式为:$$E[X] = \\frac{1}{N}\\sum_{k=0}^{N}X_{k}\\tag{2}$$速度的期望值即(1)中得到的平均值,对于也就是:$$\\overline{u_{i}}=E[u_{i}]$$ 方差(variance)变量$X$的方差公式为：$$Var[X] = \\frac{1}{N}\\sum_{k=0}^{N}(X_{k} - E[X])^{2}\\tag{3}$$根据(1)上式中$X_{k}-E[X]$即为变量$X$的脉动值$X’$,对于脉动速度$u’_{i}$:$$\\overline{u’_{i}}=Var[u’_{i}]$$在RANS model中我们的湍动能$k$即$k=\\frac{1}{2}(u’^{2}+v’^{2}+w’^{2})$，其也满足$\\overline{k}=\\frac{1}{2}Var[u]+\\frac{1}{2}Var[v]+\\frac{1}{2}Var[w]$. 标准差(standard deviation)标准差即为方差的开方：$$\\sigma_{X}=\\sqrt{Var[X]}\\tag{4}$$ 方差(covarance)协方差的定义为:$$Cov[X,Y]=\\frac{1}{N}\\sum_{k=0}^{N}(X_{k} - E[X])(Y_{k}-E[Y])\\tag{5}$$根据(1),对于任意两个速度分量的协方差$Cov[u_{i},u_{j}]$有$$Cov[u_{i},u_{j}]=\\frac{1}{N}\\sum_{k=0}^{N}u_{i}u_{j}=\\overline{u_{ij}}=\\mathbf{R}$$也就是雷诺应力 卷积与积分尺度卷积(convolution)对函数$f$求$g$的卷积为: $$f*g=\\int_{-\\infty}^{\\infty}f(\\tau)g(t-\\tau)d\\tau\\tag{6}$$卷积可以视为对一个函数求加权积。根据卷积定理,有: $$\\mathscr{F}\\{ f*g\\}=\\mathscr{F}\\{f\\}\\mathscr{F}\\{g\\}\\tag{7}$$其中$\\mathscr{F}$为傅里叶变换(Fourier transform),对(7)式求傅里叶变换得: $$f*g=\\mathscr{F}^{-1}\\{ \\mathscr{F}\\{f\\}\\mathscr{F}\\{g\\} \\}\\tag{8}$$ 互相换(cross-correlation)的定义为:$$f\\star g = \\int_{-\\infty}^{\\infty}f^{*}(\\tau)g(t+\\tau)d\\tau\\tag{9}$$其中$f^{*}$为$f$的共轭复数，根据互相关定理:$$f\\star g =\\mathscr{F}^{-1}\\{ \\mathscr{F}^{*}\\{f\\}\\mathscr{F}\\{g\\} \\}\\tag{10}$$当$f=g$的时候，$f\\star f$被称为自相关(auto-correlation)，(10)即为:$$f\\star f=\\int_{-\\infty}^{\\infty}f^{}(\\tau)(t+\\tau)d\\tau\\tag{11}$$根据互相关定理(11)即为:$$f\\star f=\\mathscr{F}^{-1}\\{\\mathscr{F}^{*}\\{f\\} \\mathscr{F}\\{f\\} \\}=\\mathscr{F}^{-1}\\{ |\\mathscr{F}\\{f\\}|^2 \\}\\tag{12}$$ 相关性(correlation)与积分尺度(integral scale)相关性其实与协方差(5)紧密相关，描述了一个变量在不同时间、空间的相关性。相关性常常写作模化的形式:模化一个变量的相关系数(correlation coefficient),最常用的有自相关系数(autocorrelation coefficient)和两点相关系数(two-point correlation coefficient)。自相关系数的定义为:$$\\rho_{i}(\\tau)=\\frac{\\overline{ u’ _{i}(t,\\mathbf{x})u’ _{i}(t+\\tau,\\mathbf{x}) }}{\\overline{u’^{2} _{i} }}\\tag{13}$$其中$\\tau$为时间变量，自相关系数也应该是对称即:$$\\rho({\\tau})=\\rho({-\\tau})$$并且位于-1(perfect correlation)到1(perfect anti-correlation)之间。两点相关系数的定义类似于自相关系数为:$$\\rho_{ij}(\\mathbf{r})=\\frac{\\overline{u’ _{i}(t,\\mathbf{x})u’ _{i}(\\mathbf{x}+\\mathbf{r})}}{\\sqrt{\\overline{ u’^{2}_{i}(\\mathbf{x}) }} \\sqrt{\\overline{ u’^{2}_{i}(\\mathbf{x} + \\mathbf{r}) }} }\\tag{14}$$其中$\\mathbf{r}$即为两点的矢量距离。 时间积分尺度(integral time scale)的定义为自相关系数$\\rho(\\tau)$(式13)的积分$$T_{i}=\\int_{0}^{\\infty}\\rho_{i}(\\tau)d\\tau\\tag{15}$$如下图所示。","categories":[{"name":"数学相关","slug":"数学相关","permalink":"https://nevermorph.github.io/categories/数学相关/"}],"tags":[{"name":"math tubulence","slug":"math-tubulence","permalink":"https://nevermorph.github.io/tags/math-tubulence/"}]},{"title":"LES进口边界条件的设置","slug":"LES进口边界条件的设置","date":"2017-07-23T12:37:36.000Z","updated":"2017-07-30T05:50:20.465Z","comments":true,"path":"2017/07/23/LES进口边界条件的设置/","link":"","permalink":"https://nevermorph.github.io/2017/07/23/LES进口边界条件的设置/","excerpt":"","text":"与RANS计算不同，LES计算设置的进口速度为滤波后的瞬时速度，因此需要对","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"https://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"LES TurbulenceModel","slug":"LES-TurbulenceModel","permalink":"https://nevermorph.github.io/tags/LES-TurbulenceModel/"}]},{"title":"OpenFOAM中的LES湍流模型及其植入","slug":"OpenFOAM中的LES湍流模型及其植入","date":"2017-07-15T03:49:03.000Z","updated":"2017-08-21T12:33:18.708Z","comments":true,"path":"2017/07/15/OpenFOAM中的LES湍流模型及其植入/","link":"","permalink":"https://nevermorph.github.io/2017/07/15/OpenFOAM中的LES湍流模型及其植入/","excerpt":"LES程序的分类在CFD计算中我们根据滤波函数的植入方法，会把LES程序分为 implicit filterint和explicit filtering方法。OpenFOAM采用的是前一种也就是隐式滤波方法，Lund给出了一个隐式滤波的定义方法: 隐式滤波程序直接写出滤波后的Navier-Stokes方程并代入了假设的sub-scale stresses，之后直接对这个方程进行求解。而实际上滤波是通过网格的截止尺寸来完成滤波的。这种方法被视为隐式滤波，因为滤波操作实际上根本没有出现在求解的过程中。 其实也就是说利用我们计算得到的结果极为网格内的平均值来进行滤波，在OpenFOAM的代码除了dynamic模型外，并不存在显示滤波的植入，实际上对于如Smagorinsky模型、WALE模型，任何滤波函数算出来的结果都是一样的。","text":"LES程序的分类在CFD计算中我们根据滤波函数的植入方法，会把LES程序分为 implicit filterint和explicit filtering方法。OpenFOAM采用的是前一种也就是隐式滤波方法，Lund给出了一个隐式滤波的定义方法: 隐式滤波程序直接写出滤波后的Navier-Stokes方程并代入了假设的sub-scale stresses，之后直接对这个方程进行求解。而实际上滤波是通过网格的截止尺寸来完成滤波的。这种方法被视为隐式滤波，因为滤波操作实际上根本没有出现在求解的过程中。 其实也就是说利用我们计算得到的结果极为网格内的平均值来进行滤波，在OpenFOAM的代码除了dynamic模型外，并不存在显示滤波的植入，实际上对于如Smagorinsky模型、WALE模型，任何滤波函数算出来的结果都是一样的。 隐式LES与RANS在代码上的区别根据这段话实际上LES在代码的植入上只需要修改N-S方程的扩散项即可，Lars Davidson[187-188]教授也提到： 任何适用于RANS的数值程序也能用到LES上，如果你有一份RANS有限体积法代码，那么很容易转成LES代码。实际上LES代码要比RANS代码更简单。 并给出了RANS与LES代码的对比: RANS LES Domain steady or unsteady always unsteady Space discretization 2nd order upwind central differncing Time discretization 1st order 2nd order Turbulence model more than 2-equations 0- or 1-equation 在代码的改造上给出了一下建议: LES中对于扩散项要求较高，需要用二阶(或者更高阶)的中心差分格式防止额外的数值耗散 时间格式也应该没有耗散，因此可以用二阶的时间格式如C-N格式 加入SGS模型。 LES模型的基本方程对笛卡尔坐标系下的连续方程进行滤波得到:$$\\frac{\\partial{\\rho}}{\\partial{t}}+\\nabla \\cdot (\\rho \\mathbf{\\overline{U}}) =0\\tag{1}$$再对笛卡尔坐标系下的Navier-Stokes方程进行滤波得到:$$\\frac{\\partial{\\mathbf{\\overline{U}}}}{\\partial{t}} + \\nabla \\cdot (\\overline{\\mathbf{U}\\mathbf{U}}) = -\\nabla\\frac{\\overline{p}}{\\rho} + \\nabla \\cdot[\\nu(\\nabla \\overline{\\mathbf{U}})+(\\nabla \\overline{\\mathbf{U}}^{\\mathrm{T}})]\\tag{2}$$把对流项拆分$\\nabla\\cdot(\\overline{\\mathbf{U}\\mathbf{U}}) = \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}}) + (\\nabla\\cdot(\\overline{\\mathbf{U}\\mathbf{U}}) - \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}}))$,假设$\\mathbf{\\tau} = \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}})- \\nabla\\cdot(\\overline{\\mathbf{U}\\mathbf{U}})$并代入(2)得到:$$\\frac{\\partial{\\mathbf{\\overline{U}}}}{\\partial{t}} + \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}}) = -\\nabla\\frac{\\overline{p}}{\\rho} + \\nabla \\cdot[\\nu(\\nabla \\overline{\\mathbf{U}})+(\\nabla \\overline{\\mathbf{U}}^{\\mathrm{T}})] + \\mathbf{\\tau}\\tag{3}$$其中$\\mathbf{\\tau}$被称为亚格子应力(SGS),通常通过下面方程进行模化:$$\\tau_{ij} = \\underbrace{\\tau_{ij} -\\frac{1}{3}\\tau_{kk}\\delta_{ij} }_{\\text{deviatoric}} + \\underbrace{\\frac{1}{3}\\tau_{kk}\\delta_{ij}}_{\\text{isotropic}}\\tag{4}$$其中deviatoric部分根据Smagorinsky模型假设有:$$\\tau_{ij}-\\frac{1}{3}\\tau_{kk}\\delta_{ij}=-2\\mu_{sgs}(\\overline{D_{ij}}-\\frac{1}{3}\\overline{D_{kk}}\\delta_{ij})=-2\\mu_{sgs}(\\mathbf{dev}(\\overline{D_{ij}}))\\tag{5}$$其中$\\overline{D_{ij}}$为平均的剪切变形率，其公式为$\\mathbf{\\overline{D}}=\\frac{1}{2}(\\nabla \\mathbf{\\overline{U}} + \\nabla\\mathbf{\\overline{U}}^{\\mathrm{T}}$),根据(1)当流体为不可压缩流体时有$\\overline{D_{kk}}=\\frac{\\partial{\\overline{U}}}{\\partial{x}} + \\frac{\\partial{\\overline{V}}}{\\partial{y}} + \\frac{\\partial{\\overline{W}}}{\\partial{z}}= \\nabla\\cdot(\\overline{\\mathbf{U}}) = 0$,那么(5)也可以写为:$$\\tau_{ij}-\\frac{1}{3}\\tau_{kk}\\delta_{ij}=-2\\mu_{sgs}(\\overline{D_{ij}})\\tag{6}$$在OpenFOAM中，可压缩与不可压缩的LES统一起来了，实际上我们用的就是公式(5)，其中$\\mu_{sgs}$被称为亚格子应力。大多数大我模拟就是对这个$\\mu_{sgs}$构造模型来封闭整个方程。下面最基础的LES模型:smagorinsky模型。 Smagorinsky模型Smagorinsky模型是由Smagorinsky在1960年代提出局部平衡假设亚格子动能$k_{SGS}$可以通过局部平衡假设来得到的:$$\\overline{\\mathbf{S}}:\\mathbf{\\tau}+C_{e}\\frac{k_{sgs}^{1.5}}{\\Delta}=0\\tag{7}$$把(5)代入(7)即得到:$$ \\overline{\\mathbf{S}}:[\\frac{2}{3}k_{sgs}\\mathbf{I}-2\\mu_{sgs}\\mathbf{dev}(\\overline{\\mathbf{S}})]+k_{sgs}^{1.5}\\frac{C_{\\epsilon}}{\\Delta} = 0\\tag{8}$$ 涡粘度假设对于亚格子粘度$\\mu_{sgs}$我们根据:$$\\mu_{sgs}=C_{k}\\Delta\\sqrt{k_{sgs}}\\tag{9}$$得到，把(9)代入(8)就可以得到:$$\\begin{align}&amp; \\overline{\\mathbf{S}}:[\\frac{2}{3}k_{sgs}\\mathbf{I}-2C_{k}\\Delta\\sqrt{k_{sgs}}]+k_{sgs}^{1.5}\\frac{C_{\\epsilon}}{\\Delta} = 0 \\\\&amp; \\Longrightarrow \\sqrt{k_{sgs}}(\\frac{C_{\\epsilon}}{\\Delta}k_{sgs}+\\frac{2}{3}\\mathbf{tr}(\\overline{\\mathbf{S}})\\sqrt{k_{sgs}}-2C_{k}(\\mathbf{dev}(\\overline{\\mathbf{S}}):\\overline{\\mathbf{S}})) = 0 \\\\&amp; \\Longrightarrow ak_{sgs}+b\\sqrt{k_{sgs}}-c = 0 \\\\\\end{align}$$其中$$\\begin{align}&amp; a=\\frac{C_{\\epsilon}}{\\Delta} \\\\&amp; b=\\frac{2}{3}tr(\\overline{\\mathbf{S}}) \\\\&amp; c=2C_{k}(\\mathbf{dev}(\\overline{\\mathbf{S}}):\\overline{\\mathbf{S}} \\\\&amp; \\sqrt{k_{sgs}}=\\frac{-b+\\sqrt{b^2+4ac}}{2a}\\end{align}\\tag{10}$$当为不可压缩流体时$tr{\\overline{\\mathbf{S}}}=0$,那么$b=0$、$c=2C_{k}(\\overline{\\mathbf{S}}:\\overline{\\mathbf{S}})$,就可以得到$k_{sgs}=\\frac{c}{a}=\\frac{2C_{k}||\\overline{\\mathbf{S}}||^{2}{}\\Delta}{C_{\\epsilon}}$。进入OpenFOAM中Smagorinsky的代码位置并打开12cd $FOAM_SRC/TurbulenceModels/turbulenceModels/LES/Smagorinskyvim Smagorinsky/Smagorinsky.H 其中通过k函数来返回公式(10)的$k_{SGS}$： 1234567891011121314151617181920212223242526template&lt;class BasicTurbulenceModel&gt;tmp&lt;volScalarField&gt; Smagorinsky&lt;BasicTurbulenceModel&gt;::k( const tmp&lt;volTensorField&gt;&amp; gradU) const&#123; volSymmTensorField D(symm(gradU)); volScalarField a(this-&gt;Ce_/this-&gt;delta()); volScalarField b((2.0/3.0)*tr(D)); volScalarField c(2*Ck_*this-&gt;delta()*(dev(D) &amp;&amp; D)); return tmp&lt;volScalarField&gt; ( new volScalarField ( IOobject ( IOobject::groupName(\"k\", this-&gt;U_.group()), this-&gt;runTime_.timeName(), this-&gt;mesh_ ), sqr((-b + sqrt(sqr(b) + 4*a*c))/(2*a)) ) );&#125; 而公式(9)的$\\mu_{SGS}$则是通过correctNut()函数来得到通过有效粘度加入N-S方程中的: 1234567891011template&lt;class BasicTurbulenceModel&gt;void Smagorinsky&lt;BasicTurbulenceModel&gt;::correctNut()&#123; volScalarField k(this-&gt;k(fvc::grad(this-&gt;U_))); this-&gt;nut_ = Ck_*this-&gt;delta()*sqrt(k); this-&gt;nut_.correctBoundaryConditions(); fv::options::New(this-&gt;mesh_).correct(this-&gt;nut_); BasicTurbulenceModel::correctNut();&#125; 具体通过修正粘度来加入湍流模型后面会详细叙述。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"https://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"LES TurbulenceModel","slug":"LES-TurbulenceModel","permalink":"https://nevermorph.github.io/tags/LES-TurbulenceModel/"}]},{"title":"OpenFOAM中涡判定准则Q的计算","slug":"OpenFOAM中的Q准则","date":"2017-06-18T14:51:00.000Z","updated":"2017-07-23T12:42:22.942Z","comments":true,"path":"2017/06/18/OpenFOAM中的Q准则/","link":"","permalink":"https://nevermorph.github.io/2017/06/18/OpenFOAM中的Q准则/","excerpt":"OpenFOAM中涡判定准则Q的计算 OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码","text":"OpenFOAM中涡判定准则Q的计算 OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码进入求OpenFOAM中求Q的代码所在位置并打开:12$ cd $FOAM_SRC/functionObjects/field/Q$ vim Q.C 我们可以看到:123456789101112131415161718bool Foam::functionObjects::Q::calc()&#123; if (foundObject&lt;volVectorField&gt;(fieldName_)) &#123; const volVectorField&amp; U = lookupObject&lt;volVectorField&gt;(fieldName_); const tmp&lt;volTensorField&gt; tgradU(fvc::grad(U)); const volTensorField&amp; gradU = tgradU(); return store ( resultName_, 0.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) ); &#125; else &#123; return false; &#125;&#125; 下面我们可以推导OpenFOAM中的方法与上述公式其实是一样的$$\\nabla \\mathbf{U}= \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} \\\\ \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} \\\\ \\frac{ \\partial{w}}{ \\partial{x}} &amp; \\frac{ \\partial{w}}{ \\partial{y}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{6}$$将(6)代入(2)有:$$\\mathbf{W}= \\frac{1}{2} \\left ( \\begin{matrix} &amp; \\frac{ \\partial{u}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{y}}&amp; &amp; \\frac{ \\partial{v}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\end{matrix} \\right ) \\tag{7}$$同理$$ \\mathbf{S} = \\frac{1}{2} \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{y}}&amp; \\frac{ \\partial{v}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{8}$$代入(1)那么有:$$Q = \\frac{1}{2}(\\frac{1}{4}(-2\\times 2\\times 2(\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})-2^{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}}))) =-\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} -\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} -\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}} -\\frac{1}{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}})\\tag{9}$$在代码中为10.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) 用数学表示，即为:$$\\frac{1}{2}(tr(\\nabla\\mathbf{U}))^2 - tr(\\nabla\\mathbf{U} \\cdot \\nabla\\mathbf{U}) =\\frac{1}{2}( (\\frac{\\partial{u}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{y}} +\\frac{\\partial{w}}{\\partial{z}})^2 ) - ((\\frac{\\partial{u}}{\\partial{x}})^2 +(\\frac{\\partial{v}}{\\partial{y}})^2 +(\\frac{\\partial{w}}{\\partial{z}})^2 +2\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +2\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +2\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})\\tag{10}$$可以看到式(10)跟式(9)的结果是相同的，这篇文章详细的推导了在OpenFOAM中的Q准则的实现,可以用来熟悉OpenFOAM的张量实现。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"https://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"postProcessing","slug":"postProcessing","permalink":"https://nevermorph.github.io/tags/postProcessing/"}]}]}