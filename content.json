{"meta":{"title":"nevermorph->CFD","subtitle":null,"description":"梅花雪月光一片","author":"nevermorph","url":"http://nevermorph.github.io"},"pages":[{"title":"categories","date":"2017-06-22T15:01:40.000Z","updated":"2017-06-22T15:14:29.075Z","comments":true,"path":"categories/index.html","permalink":"http://nevermorph.github.io/categories/index.html","excerpt":"","text":""},{"title":"email","date":"2017-07-15T03:40:16.000Z","updated":"2017-07-15T03:42:21.112Z","comments":true,"path":"email/index.html","permalink":"http://nevermorph.github.io/email/index.html","excerpt":"","text":"我的邮箱是nirvanaZen@aliyun.com ，欢迎大家共同探讨。"},{"title":"tags","date":"2017-06-22T14:49:38.000Z","updated":"2017-06-22T14:50:16.565Z","comments":true,"path":"tags/index.html","permalink":"http://nevermorph.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenFOAM中的LES湍流模型及其植入","slug":"LES","date":"2017-07-15T03:49:03.000Z","updated":"2017-07-15T04:52:20.821Z","comments":true,"path":"2017/07/15/LES/","link":"","permalink":"http://nevermorph.github.io/2017/07/15/LES/","excerpt":"","text":"OpenFOAM中的LES湍流模型及其插入OpenFOAM中湍流模型的分类在CFD计算中我们根据滤波函数的植入方法，会把LES程序分为 implicit filterint和explicit filtering方法。OpenFOAM采用的是前一种也就是隐式滤波方法，[Lund][1]给出了一个隐式滤波的定义方法:隐式滤波程序直接写出滤波后的Navier-Stokes方程并代入了假设的SGS应力（sub-scale stresses），之后直接对这个方程进行求解。而实际上滤波是通过网格的截止尺寸来完成滤波的。这种方法被视为隐式滤波，因为滤波操作实际上根本没有出现在求解的过程中。 隐式LES与RANS在代码上的区别根据这段话实际上LES在代码的植入上只需要修改N-S方程的扩散项即可，Lars Davidson[187-188]教授也提到：任何适用于RANS的数值程序也能用到LES上，如果你有一份RANS有限体积法代码，那么很容易转成LES代码。实际上LES代码要比RANS代码更简单。并给出了RANS与LES代码的对比:| &ensp; |RANS|LES||—|—–|——||Domain|2D or 3D|always 3D||Time Domain|steady or unsteady|always unsteady||Space discretization|2nd order upwind|central differncing||Time discretization|1st order|2nd order||Turbulence model|more than 2-equations| 0- or 1-equation|在代码的改造上给出了一下建议: LES中对于扩散项要求较高，需要用二阶(或者更高阶)的中心差分格式防止额外的数值耗散 时间格式也应该没有耗散，因此可以用二阶的时间格式如C-N格式—title: OpenFOAM中的LES湍流模型及其植入date: 2017-07-15 11:49:03tags: LEScategories: OpenFOAMmathjax: truecomments: true OpenFOAM中的LES湍流模型及其插入OpenFOAM中湍流模型的分类在CFD计算中我们根据滤波函数的植入方法，会把LES程序分为 implicit filterint和explicit filtering方法。OpenFOAM采用的是前一种也就是隐式滤波方法，[Lund][1]给出了一个隐式滤波的定义方法:隐式滤波程序直接写出滤波后的Navier-Stokes方程并代入了假设的SGS应力（sub-scale stresses），之后直接对这个方程进行求解。而实际上滤波是通过网格的截止尺寸来完成滤波的。这种方法被视为隐式滤波，因为滤波操作实际上根本没有出现在求解的过程中。 隐式LES与RANS在代码上的区别根据这段话实际上LES在代码的植入上只需要修改N-S方程的扩散项即可，Lars Davidson[187-188]教授也提到：任何适用于RANS的数值程序也能用到LES上，如果你有一份RANS有限体积法代码，那么很容易转成LES代码。实际上LES代码要比RANS代码更简单。并给出了RANS与LES代码的对比:| &ensp; |RANS|LES||—|—–|——||Domain|2D or 3D|always 3D||Time Domain|steady or unsteady|always unsteady||Space discretization|2nd order upwind|central differncing||Time discretization|1st order|2nd order||Turbulence model|more than 2-equations| 0- or 1-equation|在代码的改造上给出了一下建议: LES中对于扩散项要求较高，需要用二阶(或者更高阶)的中心差分格式防止额外的数值耗散 时间格式也应该没有耗散，因此可以用二阶的时间格式如C-N格式","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"LES","slug":"LES","permalink":"http://nevermorph.github.io/tags/LES/"}]},{"title":"OpenFOAM中涡判定准则Q的计算","slug":"OpenFOAM中的Q准则","date":"2017-06-18T14:51:00.000Z","updated":"2017-07-15T02:12:08.530Z","comments":true,"path":"2017/06/18/OpenFOAM中的Q准则/","link":"","permalink":"http://nevermorph.github.io/2017/06/18/OpenFOAM中的Q准则/","excerpt":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码","text":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码进入求OpenFOAM中求Q的代码所在位置并打开:12$ cd $FOAM_SRC/functionObjects/field/Q$ vim Q.C 我们可以看到:123456789101112131415161718bool Foam::functionObjects::Q::calc()&#123; if (foundObject&lt;volVectorField&gt;(fieldName_)) &#123; const volVectorField&amp; U = lookupObject&lt;volVectorField&gt;(fieldName_); const tmp&lt;volTensorField&gt; tgradU(fvc::grad(U)); const volTensorField&amp; gradU = tgradU(); return store ( resultName_, 0.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) ); &#125; else &#123; return false; &#125;&#125; 下面我们可以推导OpenFOAM中的方法与上述公式其实是一样的$$\\nabla \\mathbf{U}= \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} \\\\ \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} \\\\ \\frac{ \\partial{w}}{ \\partial{x}} &amp; \\frac{ \\partial{w}}{ \\partial{y}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{6}$$将(6)代入(2)有:$$\\mathbf{W}= \\frac{1}{2} \\left ( \\begin{matrix} &amp; \\frac{ \\partial{u}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{y}}&amp; &amp; \\frac{ \\partial{v}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\end{matrix} \\right ) \\tag{7}$$同理$$ \\mathbf{S} = \\frac{1}{2} \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{y}}&amp; \\frac{ \\partial{v}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{8}$$代入(1)那么有:$$Q = \\frac{1}{2}(\\frac{1}{4}(-2\\times 2\\times 2(\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})-2^{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}}))) =-\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} -\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} -\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}} -\\frac{1}{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}})\\tag{9}$$在代码中为10.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) 用数学表示，即为:$$\\frac{1}{2}(tr(\\nabla\\mathbf{U}))^2 - tr(\\nabla\\mathbf{U} \\cdot \\nabla\\mathbf{U}) =\\frac{1}{2}( (\\frac{\\partial{u}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{y}} +\\frac{\\partial{w}}{\\partial{z}})^2 ) - ((\\frac{\\partial{u}}{\\partial{x}})^2 +(\\frac{\\partial{v}}{\\partial{y}})^2 +(\\frac{\\partial{w}}{\\partial{z}})^2 +2\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +2\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +2\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})\\tag{10}$$可以看到式(10)跟式(9)的结果是相同的，这篇文章详细的推导了在OpenFOAM中的Q准则的实现,可以用来熟悉OpenFOAM的张量实现。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"postProcessing","slug":"postProcessing","permalink":"http://nevermorph.github.io/tags/postProcessing/"}]}]}