{"meta":{"title":"nevermorph->CFD","subtitle":null,"description":null,"author":"nevermorph","url":"http://nevermorph.github.io"},"pages":[{"title":"categories","date":"2017-06-22T15:01:40.000Z","updated":"2017-06-22T15:02:09.747Z","comments":true,"path":"categories/index.html","permalink":"http://nevermorph.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-22T14:49:38.000Z","updated":"2017-06-22T14:50:16.565Z","comments":true,"path":"tags/index.html","permalink":"http://nevermorph.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenFOAM中涡判定准则Q的计算","slug":"OpenFOAM中的Q准则","date":"2017-06-18T14:51:00.000Z","updated":"2017-06-22T14:58:53.524Z","comments":true,"path":"2017/06/18/OpenFOAM中的Q准则/","link":"","permalink":"http://nevermorph.github.io/2017/06/18/OpenFOAM中的Q准则/","excerpt":"","text":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\vec{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 + (\\left \\lVert \\mathbf{S} \\right \\rVert)^2) $$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\\\\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\\\\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\\\\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2}$$而我们观察OpenFOAM中的代码进入求OpenFOAM中求Q的代码所在位置并打开:12$ cd $FOAM_SRC/functionObjects/field/Q$ vim Q.C 我们可以看到:12345678910111213141516171819bool Foam::functionObjects::Q::calc()&#123; if (foundObject&lt;volVectorField&gt;(fieldName_)) &#123; const volVectorField&amp; U = lookupObject&lt;volVectorField&gt;(fieldName_); const tmp&lt;volTensorField&gt; tgradU(fvc::grad(U)); const volTensorField&amp; gradU = tgradU(); return store ( resultName_, 0.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) ); &#125; else &#123; return false; &#125;&#125; 我们可以推导OpenFOAM中的方法与上述公式其实是一样的，其推导过程可以如下:$$\\nabla \\vec{U} = \\begion{pmatrix} \\frac{\\partial u}{\\partial x} &amp; \\frac{\\partial u}{\\partial y} &amp; \\frac{\\partial u}{\\partial z}\\\\frac{\\partial v}{\\partial x} &amp; \\frac{\\partial v}{\\partial y} &amp; \\frac{\\partial v}{\\partial z} \\\\frac{\\partial w}{\\partial x} &amp; \\frac{\\partial w}{\\partial y} &amp; \\frac{\\partial w}{\\partial z} \\end{pmatrix}$$","categories":[],"tags":[{"name":"postProcessing","slug":"postProcessing","permalink":"http://nevermorph.github.io/tags/postProcessing/"}]}]}