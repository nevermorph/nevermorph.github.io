{"meta":{"title":"nevermorph->CFD","subtitle":null,"description":"梅花雪月光一片","author":"nevermorph","url":"http://nevermorph.github.io"},"pages":[{"title":"categories","date":"2017-06-22T15:01:40.000Z","updated":"2017-06-22T15:14:29.075Z","comments":true,"path":"categories/index.html","permalink":"http://nevermorph.github.io/categories/index.html","excerpt":"","text":""},{"title":"email","date":"2017-07-15T03:40:16.000Z","updated":"2017-07-15T03:42:21.112Z","comments":true,"path":"email/index.html","permalink":"http://nevermorph.github.io/email/index.html","excerpt":"","text":"我的邮箱是nirvanaZen@aliyun.com ，欢迎大家共同探讨。"},{"title":"tags","date":"2017-06-22T14:49:38.000Z","updated":"2017-06-22T14:50:16.565Z","comments":true,"path":"tags/index.html","permalink":"http://nevermorph.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenFOAM中的LES湍流模型及其植入","slug":"OpenFOAM中的LES湍流模型及其植入","date":"2017-07-15T03:49:03.000Z","updated":"2017-07-15T07:54:04.939Z","comments":true,"path":"2017/07/15/OpenFOAM中的LES湍流模型及其植入/","link":"","permalink":"http://nevermorph.github.io/2017/07/15/OpenFOAM中的LES湍流模型及其植入/","excerpt":"LES程序的分类在CFD计算中我们根据滤波函数的植入方法，会把LES程序分为 implicit filterint和explicit filtering方法。OpenFOAM采用的是前一种也就是隐式滤波方法，Lund给出了一个隐式滤波的定义方法: 隐式滤波程序直接写出滤波后的Navier-Stokes方程并代入了假设的SGS应力（sub-scale stresses），之后直接对这个方程进行求解。而实际上滤波是通过网格的截止尺寸来完成滤波的。这种方法被视为隐式滤波，因为滤波操作实际上根本没有出现在求解的过程中。 在OpenFOAM的代码除了dynamic模型外，并不存在显示滤波的植入。","text":"LES程序的分类在CFD计算中我们根据滤波函数的植入方法，会把LES程序分为 implicit filterint和explicit filtering方法。OpenFOAM采用的是前一种也就是隐式滤波方法，Lund给出了一个隐式滤波的定义方法: 隐式滤波程序直接写出滤波后的Navier-Stokes方程并代入了假设的SGS应力（sub-scale stresses），之后直接对这个方程进行求解。而实际上滤波是通过网格的截止尺寸来完成滤波的。这种方法被视为隐式滤波，因为滤波操作实际上根本没有出现在求解的过程中。 在OpenFOAM的代码除了dynamic模型外，并不存在显示滤波的植入。 隐式LES与RANS在代码上的区别根据这段话实际上LES在代码的植入上只需要修改N-S方程的扩散项即可，Lars Davidson[187-188]教授也提到： 任何适用于RANS的数值程序也能用到LES上，如果你有一份RANS有限体积法代码，那么很容易转成LES代码。实际上LES代码要比RANS代码更简单。 并给出了RANS与LES代码的对比: RANS LES Domain steady or unsteady always unsteady Space discretization 2nd order upwind central differncing Time discretization 1st order 2nd order Turbulence model more than 2-equations 0- or 1-equation 在代码的改造上给出了一下建议: LES中对于扩散项要求较高，需要用二阶(或者更高阶)的中心差分格式防止额外的数值耗散 时间格式也应该没有耗散，因此可以用二阶的时间格式如C-N格式 加入SGS模型。 LES模型的基本方程对笛卡尔坐标系下的连续方程进行滤波得到:$$\\frac{\\partial{\\rho}}{\\partial{t}}+\\nabla \\cdot (\\rho \\mathbf{\\overline{U}}) =0\\tag{1}$$再对笛卡尔坐标系下的Navier-Stokes方程进行滤波得到:$$\\frac{\\partial{\\mathbf{\\overline{U}}}}{\\partial{t}} + \\nabla \\cdot (\\overline{\\mathbf{U}\\mathbf{U}}) = -\\nabla\\frac{\\overline{p}}{\\rho} + \\nabla \\cdot[\\nu(\\nabla \\overline{\\mathbf{U}})+(\\nabla \\overline{\\mathbf{U}}^{\\mathrm{T}})]\\tag{2}$$把对流项拆分$\\nabla\\cdot(\\overline{\\mathbf{U}\\mathbf{U}}) = \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}}) + (\\nabla\\cdot(\\overline{\\mathbf{U}\\mathbf{U}}) - \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}}))$,假设$\\mathbf{\\tau} = \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}})- \\nabla\\cdot(\\overline{\\mathbf{U}\\mathbf{U}})$并代入(2)得到:$$\\frac{\\partial{\\mathbf{\\overline{U}}}}{\\partial{t}} + \\nabla\\cdot(\\overline{\\mathbf{U}}\\mathop{\\overline{\\mathbf{U}}}) = -\\nabla\\frac{\\overline{p}}{\\rho} + \\nabla \\cdot[\\nu(\\nabla \\overline{\\mathbf{U}})+(\\nabla \\overline{\\mathbf{U}}^{\\mathrm{T}})] + \\mathbf{\\tau}\\tag{3}$$其中$\\mathbf{\\tau}$被称为亚格子应力(SGS),通常通过下面方程进行模化:$$\\tau_{ij} = \\underbrace{\\tau_{ij} -\\frac{1}{3}\\tau_{kk}\\delta_{ij} }_{\\text{deviatoric}} + \\underbrace{\\frac{1}{3}\\tau_{kk}\\delta_{ij}}_{\\text{isotropic}}\\tag{4}$$其中deviatoric部分根据Smagorinsky模型假设有:$$\\tau_{ij}-\\frac{1}{3}\\tau_{kk}\\delta_{ij}=-2\\mu_{sgs}(\\overline{D_{ij}}-\\frac{1}{3}\\overline{D_{kk}}\\delta_{ij})=-2\\mu_{sgs}(\\mathbf{dev}(\\overline{D_{ij}}))\\tag{5}$$其中$\\overline{D_{ij}}$为平均的剪切变形率，其公式为$\\mathbf{\\overline{D}}=\\frac{1}{2}(\\nabla \\mathbf{\\overline{U}} + \\nabla\\mathbf{\\overline{U}}^{\\mathrm{T}}$),根据(1)当流体为不可压缩流体时有$\\overline{D_{kk}}=\\frac{\\partial{\\overline{U}}}{\\partial{x}} + \\frac{\\partial{\\overline{V}}}{\\partial{y}} + \\frac{\\partial{\\overline{W}}}{\\partial{z}}= \\nabla\\cdot(\\overline{\\mathbf{U}}) = 0$,那么(5)也可以写为: $$\\tau_{ij}-\\frac{1}{3}\\tau_{kk}\\delta_{ij}=-2\\mu_{sgs}(\\overline{D_{ij}})\\tag{6}$$在OpenFOAM中，可压缩与不可压缩的LES统一起来了，实际上我们用的就是公式(5)。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"LES","slug":"LES","permalink":"http://nevermorph.github.io/tags/LES/"}]},{"title":"OpenFOAM中涡判定准则Q的计算","slug":"OpenFOAM中的Q准则","date":"2017-06-18T14:51:00.000Z","updated":"2017-07-15T02:12:08.530Z","comments":true,"path":"2017/06/18/OpenFOAM中的Q准则/","link":"","permalink":"http://nevermorph.github.io/2017/06/18/OpenFOAM中的Q准则/","excerpt":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码","text":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码进入求OpenFOAM中求Q的代码所在位置并打开:12$ cd $FOAM_SRC/functionObjects/field/Q$ vim Q.C 我们可以看到:123456789101112131415161718bool Foam::functionObjects::Q::calc()&#123; if (foundObject&lt;volVectorField&gt;(fieldName_)) &#123; const volVectorField&amp; U = lookupObject&lt;volVectorField&gt;(fieldName_); const tmp&lt;volTensorField&gt; tgradU(fvc::grad(U)); const volTensorField&amp; gradU = tgradU(); return store ( resultName_, 0.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) ); &#125; else &#123; return false; &#125;&#125; 下面我们可以推导OpenFOAM中的方法与上述公式其实是一样的$$\\nabla \\mathbf{U}= \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} \\\\ \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} \\\\ \\frac{ \\partial{w}}{ \\partial{x}} &amp; \\frac{ \\partial{w}}{ \\partial{y}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{6}$$将(6)代入(2)有:$$\\mathbf{W}= \\frac{1}{2} \\left ( \\begin{matrix} &amp; \\frac{ \\partial{u}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{y}}&amp; &amp; \\frac{ \\partial{v}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\end{matrix} \\right ) \\tag{7}$$同理$$ \\mathbf{S} = \\frac{1}{2} \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{y}}&amp; \\frac{ \\partial{v}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{8}$$代入(1)那么有:$$Q = \\frac{1}{2}(\\frac{1}{4}(-2\\times 2\\times 2(\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})-2^{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}}))) =-\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} -\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} -\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}} -\\frac{1}{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}})\\tag{9}$$在代码中为10.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) 用数学表示，即为:$$\\frac{1}{2}(tr(\\nabla\\mathbf{U}))^2 - tr(\\nabla\\mathbf{U} \\cdot \\nabla\\mathbf{U}) =\\frac{1}{2}( (\\frac{\\partial{u}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{y}} +\\frac{\\partial{w}}{\\partial{z}})^2 ) - ((\\frac{\\partial{u}}{\\partial{x}})^2 +(\\frac{\\partial{v}}{\\partial{y}})^2 +(\\frac{\\partial{w}}{\\partial{z}})^2 +2\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +2\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +2\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})\\tag{10}$$可以看到式(10)跟式(9)的结果是相同的，这篇文章详细的推导了在OpenFOAM中的Q准则的实现,可以用来熟悉OpenFOAM的张量实现。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"postProcessing","slug":"postProcessing","permalink":"http://nevermorph.github.io/tags/postProcessing/"}]}]}