{"meta":{"title":"nirvana->zen","subtitle":"金光烁屋 锐气盈庭","description":"金光烁屋 锐气盈庭","author":"nirvana. w.l.","url":"https://nevermorph.github.io"},"pages":[{"title":"categories","date":"2017-06-22T15:01:40.000Z","updated":"2017-06-22T15:14:29.075Z","comments":true,"path":"categories/index.html","permalink":"https://nevermorph.github.io/categories/index.html","excerpt":"","text":""},{"title":"email","date":"2017-07-15T03:40:16.000Z","updated":"2017-07-23T07:56:35.495Z","comments":true,"path":"email/index.html","permalink":"https://nevermorph.github.io/email/index.html","excerpt":"","text":"我的邮箱是nirvanaZen@aliyun.com ，欢迎大家共同探讨。"},{"title":"tags","date":"2017-06-22T14:49:38.000Z","updated":"2017-06-22T14:50:16.565Z","comments":true,"path":"tags/index.html","permalink":"https://nevermorph.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"壁面条件","slug":"壁面条件","date":"2018-01-01T13:32:52.000Z","updated":"2018-01-01T13:32:52.323Z","comments":true,"path":"2018/01/01/壁面条件/","link":"","permalink":"https://nevermorph.github.io/2018/01/01/壁面条件/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"湍流模拟常用数学公式","slug":"湍流模拟常见物理量","date":"2017-08-02T14:41:15.000Z","updated":"2018-01-01T13:29:18.088Z","comments":true,"path":"2017/08/02/湍流模拟常见物理量/","link":"","permalink":"https://nevermorph.github.io/2017/08/02/湍流模拟常见物理量/","excerpt":"统计平均量与湍流描述 实验中得到的湍流信号是一个随机量，因此常常使用统计学概念描述一些物理现象，下面是一些统计量和其物理概念:","text":"统计平均量与湍流描述 实验中得到的湍流信号是一个随机量，因此常常使用统计学概念描述一些物理现象，下面是一些统计量和其物理概念: 雷诺平均(Reynolds Average)雷诺分解将任意瞬时的速度分解脉动量与平均量如(1)所示:$$u=\\overline{u}+u’\\tag{1}$$其中$\\overline{u}$为u的平均值，$u’$即每时刻的脉动值。 期望值(expect value)变量$X$的期望值其公式为:$$E[X] = \\frac{1}{N}\\sum_{k=0}^{N}X_{k}\\tag{2}$$速度的期望值即(1)中得到的平均值,对于也就是:$$\\overline{u_{i}}=E[u_{i}]$$ 方差(variance)变量$X$的方差公式为：$$Var[X] = \\frac{1}{N}\\sum_{k=0}^{N}(X_{k} - E[X])^{2}\\tag{3}$$根据(1)上式中$X_{k}-E[X]$即为变量$X$的脉动值$X’$,对于脉动速度$u’_{i}$:$$\\overline{u’_{i}}=Var[u’_{i}]$$在RANS model中我们的湍动能$k$即$k=\\frac{1}{2}(u’^{2}+v’^{2}+w’^{2})$，其也满足$\\overline{k}=\\frac{1}{2}Var[u]+\\frac{1}{2}Var[v]+\\frac{1}{2}Var[w]$. 标准差(standard deviation)标准差即为方差的开方：$$\\sigma_{X}=\\sqrt{Var[X]}\\tag{4}$$ 方差(covarance)协方差的定义为:$$Cov[X,Y]=\\frac{1}{N}\\sum_{k=0}^{N}(X_{k} - E[X])(Y_{k}-E[Y])\\tag{5}$$根据(1),对于任意两个速度分量的协方差$Cov[u_{i},u_{j}]$有$$Cov[u_{i},u_{j}]=\\frac{1}{N}\\sum_{k=0}^{N}u_{i}u_{j}=\\overline{u_{ij}}=\\mathbf{R}$$也就是雷诺应力 卷积与积分尺度卷积(convolution)对函数$f$求$g$的卷积为: $$f*g=\\int_{-\\infty}^{\\infty}f(\\tau)g(t-\\tau)d\\tau\\tag{6}$$卷积可以视为对一个函数求加权积。根据卷积定理,有: $$\\mathscr{F}\\{ f*g\\}=\\mathscr{F}\\{f\\}\\mathscr{F}\\{g\\}\\tag{7}$$其中$\\mathscr{F}$为傅里叶变换(Fourier transform),对(7)式求傅里叶变换得: $$f*g=\\mathscr{F}^{-1}\\{ \\mathscr{F}\\{f\\}\\mathscr{F}\\{g\\} \\}\\tag{8}$$ 互相换(cross-correlation)的定义为:$$f\\star g = \\int_{-\\infty}^{\\infty}f^{*}(\\tau)g(t+\\tau)d\\tau\\tag{9}$$其中$f^{*}$为$f$的共轭复数，根据互相关定理:$$f\\star g =\\mathscr{F}^{-1}\\{ \\mathscr{F}^{*}\\{f\\}\\mathscr{F}\\{g\\} \\}\\tag{10}$$当$f=g$的时候，$f\\star f$被称为自相关(auto-correlation)，(10)即为:$$f\\star f=\\int_{-\\infty}^{\\infty}f^{}(\\tau)(t+\\tau)d\\tau\\tag{11}$$根据互相关定理(11)即为:$$f\\star f=\\mathscr{F}^{-1}\\{\\mathscr{F}^{*}\\{f\\} \\mathscr{F}\\{f\\} \\}=\\mathscr{F}^{-1}\\{ |\\mathscr{F}\\{f\\}|^2 \\}\\tag{12}$$ 相关性(correlation)与积分尺度(integral scale)相关性其实与协方差(5)紧密相关，描述了一个变量在不同时间、空间的相关性。相关性常常写作模化的形式:模化一个变量的相关系数(correlation coefficient),最常用的有自相关系数(autocorrelation coefficient)和两点相关系数(two-point correlation coefficient)。自相关系数的定义为:$$\\rho_{i}(\\tau)=\\frac{\\overline{ u’ _{i}(t,\\mathbf{x})u’ _{i}(t+\\tau,\\mathbf{x}) }}{\\overline{u’^{2} _{i} }}\\tag{13}$$其中$\\tau$为时间变量，自相关系数也应该是对称即:$$\\rho({\\tau})=\\rho({-\\tau})$$并且位于-1(perfect correlation)到1(perfect anti-correlation)之间。两点相关系数的定义类似于自相关系数为:$$\\rho_{ij}(\\mathbf{r})=\\frac{\\overline{u’ _{i}(t,\\mathbf{x})u’ _{i}(\\mathbf{x}+\\mathbf{r})}}{\\sqrt{\\overline{ u’^{2}_{i}(\\mathbf{x}) }} \\sqrt{\\overline{ u’^{2}_{i}(\\mathbf{x} + \\mathbf{r}) }} }\\tag{14}$$其中$\\mathbf{r}$即为两点的矢量距离。 时间积分尺度(integral time scale)的定义为自相关系数$\\rho(\\tau)$(式13)的积分$$T_{i}=\\int_{0}^{\\infty}\\rho_{i}(\\tau)d\\tau\\tag{15}$$如下图所示。","categories":[{"name":"数学相关","slug":"数学相关","permalink":"https://nevermorph.github.io/categories/数学相关/"}],"tags":[{"name":"math tubulence","slug":"math-tubulence","permalink":"https://nevermorph.github.io/tags/math-tubulence/"}]},{"title":"OpenFOAM中涡判定准则Q的计算","slug":"OpenFOAM中的Q准则","date":"2017-06-18T14:51:00.000Z","updated":"2017-07-23T12:42:22.942Z","comments":true,"path":"2017/06/18/OpenFOAM中的Q准则/","link":"","permalink":"https://nevermorph.github.io/2017/06/18/OpenFOAM中的Q准则/","excerpt":"OpenFOAM中涡判定准则Q的计算 OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码","text":"OpenFOAM中涡判定准则Q的计算 OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码进入求OpenFOAM中求Q的代码所在位置并打开:12$ cd $FOAM_SRC/functionObjects/field/Q$ vim Q.C 我们可以看到:123456789101112131415161718bool Foam::functionObjects::Q::calc()&#123; if (foundObject&lt;volVectorField&gt;(fieldName_)) &#123; const volVectorField&amp; U = lookupObject&lt;volVectorField&gt;(fieldName_); const tmp&lt;volTensorField&gt; tgradU(fvc::grad(U)); const volTensorField&amp; gradU = tgradU(); return store ( resultName_, 0.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) ); &#125; else &#123; return false; &#125;&#125; 下面我们可以推导OpenFOAM中的方法与上述公式其实是一样的$$\\nabla \\mathbf{U}= \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} \\\\ \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} \\\\ \\frac{ \\partial{w}}{ \\partial{x}} &amp; \\frac{ \\partial{w}}{ \\partial{y}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{6}$$将(6)代入(2)有:$$\\mathbf{W}= \\frac{1}{2} \\left ( \\begin{matrix} &amp; \\frac{ \\partial{u}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{y}}&amp; &amp; \\frac{ \\partial{v}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\end{matrix} \\right ) \\tag{7}$$同理$$ \\mathbf{S} = \\frac{1}{2} \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{y}}&amp; \\frac{ \\partial{v}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{8}$$代入(1)那么有:$$Q = \\frac{1}{2}(\\frac{1}{4}(-2\\times 2\\times 2(\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})-2^{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}}))) =-\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} -\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} -\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}} -\\frac{1}{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}})\\tag{9}$$在代码中为10.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) 用数学表示，即为:$$\\frac{1}{2}(tr(\\nabla\\mathbf{U}))^2 - tr(\\nabla\\mathbf{U} \\cdot \\nabla\\mathbf{U}) =\\frac{1}{2}( (\\frac{\\partial{u}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{y}} +\\frac{\\partial{w}}{\\partial{z}})^2 ) - ((\\frac{\\partial{u}}{\\partial{x}})^2 +(\\frac{\\partial{v}}{\\partial{y}})^2 +(\\frac{\\partial{w}}{\\partial{z}})^2 +2\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +2\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +2\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})\\tag{10}$$可以看到式(10)跟式(9)的结果是相同的，这篇文章详细的推导了在OpenFOAM中的Q准则的实现,可以用来熟悉OpenFOAM的张量实现。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"https://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"postProcessing","slug":"postProcessing","permalink":"https://nevermorph.github.io/tags/postProcessing/"}]}]}