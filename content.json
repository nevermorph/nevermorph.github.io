{"meta":{"title":"nevermorph->CFD","subtitle":null,"description":"梅花雪月光一片","author":"nevermorph","url":"http://nevermorph.github.io"},"pages":[{"title":"email","date":"2017-07-15T03:40:16.000Z","updated":"2017-07-15T03:42:21.112Z","comments":true,"path":"email/index.html","permalink":"http://nevermorph.github.io/email/index.html","excerpt":"","text":"我的邮箱是nirvanaZen@aliyun.com ，欢迎大家共同探讨。"},{"title":"categories","date":"2017-06-22T15:01:40.000Z","updated":"2017-06-22T15:14:29.075Z","comments":true,"path":"categories/index.html","permalink":"http://nevermorph.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-22T14:49:38.000Z","updated":"2017-06-22T14:50:16.565Z","comments":true,"path":"tags/index.html","permalink":"http://nevermorph.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LES","slug":"LES","date":"2017-07-15T03:49:03.000Z","updated":"2017-07-15T03:49:03.866Z","comments":true,"path":"2017/07/15/LES/","link":"","permalink":"http://nevermorph.github.io/2017/07/15/LES/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"OpenFOAM中涡判定准则Q的计算","slug":"OpenFOAM中的Q准则","date":"2017-06-18T14:51:00.000Z","updated":"2017-07-15T02:12:08.530Z","comments":true,"path":"2017/06/18/OpenFOAM中的Q准则/","link":"","permalink":"http://nevermorph.github.io/2017/06/18/OpenFOAM中的Q准则/","excerpt":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码","text":"#OpenFOAM中涡判定准则Q的计算OpenFOAM中的自带了一个涡的提取方法，在OpenFOAM4.X的版本输入1$ postProcess -func Q 即可以得到速度梯度$\\nabla \\mathbf{U}$的二阶不变量，其定义为:$$Q = \\frac{1}{2}(\\left \\lVert \\mathbf{W} \\right \\rVert^2 -\\left \\lVert \\mathbf{S} \\right \\rVert^2) \\tag{1}$$其中$$\\mathbf{W} = \\frac{1}{2} \\Big( \\nabla \\mathbf{U} - (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{2} $$$$\\left \\lVert \\mathbf{W}\\right \\rVert = (\\mathbf{W}:\\mathbf{W})^{1/2} \\tag{3} $$$$\\mathbf{S} = \\frac{1}{2} \\Big ( \\nabla \\mathbf{U} + (\\nabla \\mathbf{U}) ^{\\mathrm{T}} \\Big ) \\tag{4} $$$$\\left \\lVert \\mathbf{S}\\right \\rVert = (\\mathbf{S}:\\mathbf{S})^{1/2} \\tag{5}$$而我们观察OpenFOAM中的代码进入求OpenFOAM中求Q的代码所在位置并打开:12$ cd $FOAM_SRC/functionObjects/field/Q$ vim Q.C 我们可以看到:123456789101112131415161718bool Foam::functionObjects::Q::calc()&#123; if (foundObject&lt;volVectorField&gt;(fieldName_)) &#123; const volVectorField&amp; U = lookupObject&lt;volVectorField&gt;(fieldName_); const tmp&lt;volTensorField&gt; tgradU(fvc::grad(U)); const volTensorField&amp; gradU = tgradU(); return store ( resultName_, 0.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) ); &#125; else &#123; return false; &#125;&#125; 下面我们可以推导OpenFOAM中的方法与上述公式其实是一样的$$\\nabla \\mathbf{U}= \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} \\\\ \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} \\\\ \\frac{ \\partial{w}}{ \\partial{x}} &amp; \\frac{ \\partial{w}}{ \\partial{y}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{6}$$将(6)代入(2)有:$$\\mathbf{W}= \\frac{1}{2} \\left ( \\begin{matrix} &amp; \\frac{ \\partial{u}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{y}}&amp; &amp; \\frac{ \\partial{v}}{ \\partial{z}} - \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} - \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} - \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\end{matrix} \\right ) \\tag{7}$$同理$$ \\mathbf{S} = \\frac{1}{2} \\left ( \\begin{matrix} \\frac{ \\partial{u}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{x}} &amp; \\frac{ \\partial{u}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{v}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{y}}&amp; \\frac{ \\partial{v}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{y}} &amp; \\frac{ \\partial{v}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{x}}\\\\ \\frac{ \\partial{w}}{ \\partial{x}} + \\frac{ \\partial{u}}{ \\partial{z}}&amp; \\frac{ \\partial{w}}{ \\partial{y}} + \\frac{ \\partial{v}}{ \\partial{z}} &amp; \\frac{ \\partial{w}}{ \\partial{z}} + \\frac{ \\partial{w}}{ \\partial{z}} \\end{matrix} \\right ) \\tag{8}$$代入(1)那么有:$$Q = \\frac{1}{2}(\\frac{1}{4}(-2\\times 2\\times 2(\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})-2^{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}}))) =-\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} -\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} -\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}} -\\frac{1}{2}(\\frac{\\partial{u^{2}}}{\\partial{x^{2}}} +\\frac{\\partial{v^{2}}}{\\partial{y^{2}}} +\\frac{\\partial{w^{2}}}{\\partial{z^{2}}})\\tag{9}$$在代码中为10.5*(sqr(tr(gradU)) - tr(((gradU) &amp; (gradU)))) 用数学表示，即为:$$\\frac{1}{2}(tr(\\nabla\\mathbf{U}))^2 - tr(\\nabla\\mathbf{U} \\cdot \\nabla\\mathbf{U}) =\\frac{1}{2}( (\\frac{\\partial{u}}{\\partial{x}} +\\frac{\\partial{v}}{\\partial{y}} +\\frac{\\partial{w}}{\\partial{z}})^2 ) - ((\\frac{\\partial{u}}{\\partial{x}})^2 +(\\frac{\\partial{v}}{\\partial{y}})^2 +(\\frac{\\partial{w}}{\\partial{z}})^2 +2\\frac{\\partial{u}}{\\partial{y}} \\frac{\\partial{v}}{\\partial{x}} +2\\frac{\\partial{u}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{x}} +2\\frac{\\partial{v}}{\\partial{z}} \\frac{\\partial{w}}{\\partial{y}})\\tag{10}$$可以看到式(10)跟式(9)的结果是相同的，这篇文章详细的推导了在OpenFOAM中的Q准则的实现,可以用来熟悉OpenFOAM的张量实现。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://nevermorph.github.io/categories/OpenFOAM/"}],"tags":[{"name":"postProcessing","slug":"postProcessing","permalink":"http://nevermorph.github.io/tags/postProcessing/"}]}]}